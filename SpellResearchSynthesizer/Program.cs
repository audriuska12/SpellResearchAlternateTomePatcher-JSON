using System;
using System.Collections.Generic;
using System.Linq;
using Mutagen.Bethesda;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.Skyrim;
using System.Threading.Tasks;

using System.IO;
using System.Text.RegularExpressions;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Plugins.Order;
using Mutagen.Bethesda.Plugins.Records;

using Newtonsoft.Json.Linq;
using System.Diagnostics;
using SpellResearchSynthesizer.Classes;
using Newtonsoft.Json;
using static SpellResearchSynthesizer.Classes.Archetype;

namespace SpellResearchSynthesizer
{

    public class Program
    {
        static Lazy<Settings> settings = null!;

        public static async Task<int> Main(string[] args)
        {
            return await SynthesisPipeline.Instance
                .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
                .SetTypicalOpen(GameRelease.SkyrimSE, "SpellResearchSynthesizer.esp")
                .SetAutogeneratedSettings(
                    nickname: "Spell Research Synthesizer Settings",
                    path: "synthesizer.json",
                    out settings)
                .Run(args);

        }

        private static readonly char[] wovels = { 'a', 'e', 'i', 'o', 'u' };

        // Creates a string description of a spell given its archetypes
        private static string ProcessText(SpellInfo spell, ArchetypeVisualInfo archetypemap, LevelSettings s)
        {
            if (spell.Tier == null) throw new Exception("Spell has no tier!");
            if (spell.School == null) throw new Exception("Spell has no school!");
            if (spell.CastingType == null) throw new Exception("Spell has no casting type!");
            string strbuilder = "";
            strbuilder += $"{(wovels.Contains(spell.Tier.Name.ToLower()[0]) ? "An " : "A ")}{spell.Tier.Name.CapitalizeFirst()} spell of the ";
            if (s.UseFontColor)
            {
                strbuilder += $"<font color='{(archetypemap.Archetypes[spell.School.Name.ToLower()].Color ?? "#000000")}'>";
            }
            strbuilder += spell.School.Name.CapitalizeFirst();
            if (s.UseFontColor)
            {
                strbuilder += "</font><font color='#000000'>";
            }
            strbuilder += " school, ";
            switch (spell.CastingType.Name.ToLower())
            {
                case "concentration":
                    {
                        strbuilder += "cast through steady concentration. ";
                        break;
                    }
                case "fireandforget":
                    {
                        strbuilder += "cast in a single moment. ";
                        break;
                    }
                default:
                    break;
            }

            foreach (Archetype target in spell.Targeting)
            {
                switch (target.Name.ToLower())
                {
                    case "actor":
                        {

                            strbuilder += "This spell is fired where aimed. ";
                            break;
                        }
                    case "area":
                        {
                            strbuilder += "This spell has an area of effect. ";
                            break;
                        }
                    case "location":
                        {
                            strbuilder += "This spell is cast in a specific location. ";
                            break;
                        }
                    case "self":
                        {
                            strbuilder += "This spell is cast on oneself. ";
                            break;
                        }
                    default: break;
                }
            }

            if (spell.Elements.Count > 0)
            {
                strbuilder += $"Channels the element{(spell.Elements.Count > 1 ? "s" : string.Empty)} of ";
                if (s.UseFontColor)
                {
                    strbuilder += "</font>";
                }
                int idx = 0;
                foreach (Archetype e in spell.Elements)
                {
                    if (idx > 0 && idx == spell.Elements.Count - 1)
                        strbuilder += " and ";
                    else if (idx > 0)
                    {
                        strbuilder += ", ";
                    }
                    if (s.UseFontColor)
                    {
                        strbuilder += $"<font color='{archetypemap.Archetypes[e.Name.ToLower()]?.Color ?? "#000000"}'>";
                    }
                    strbuilder += e.Name[0..1].ToUpper() + e.Name[1..];
                    if (s.UseFontColor)
                    {
                        strbuilder += "</font>";
                    }
                    idx += 1;
                }
                strbuilder += ". ";
            }

            if (spell.Techniques.Count > 0)
            {
                if (spell.Elements.Count > 0 && s.UseFontColor)
                {
                    strbuilder += "<font color='#000000'>";
                }
                strbuilder += $"Utilizes the technique{(spell.Techniques.Count > 1 ? 's' : string.Empty)} of ";
                if (s.UseFontColor)
                {
                    strbuilder += "</font>";
                }
                int idx = 0;
                foreach (Archetype t in spell.Techniques)
                {
                    if (idx > 0 && idx == spell.Techniques.Count - 1)
                        strbuilder += " and ";
                    else if (idx > 0)
                    {
                        strbuilder += ", ";
                    }
                    if (s.UseFontColor)
                    {
                        strbuilder += $"<font color='{archetypemap.Archetypes[t.Name.ToLower()]?.Color ?? "#000000"}'>";
                    }
                    strbuilder += t.Name[0..1].ToUpper() + t.Name[1..];
                    if (s.UseFontColor)
                    {
                        strbuilder += "</font>";
                    }
                    idx += 1;
                }
                strbuilder += ".";
            }

            return strbuilder;
        }

        public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            string extraSettingsPath = Path.Combine(state.ExtraSettingsDataPath ?? throw new Exception("Extra settings data path missing"), "config.json");
            if (!File.Exists(extraSettingsPath)) throw new ArgumentException($"Archetype display settings missing! {extraSettingsPath}");
            string configText = File.ReadAllText(extraSettingsPath);
            ArchetypeVisualInfo archConfig = LoadArchetypeVisualInfo(configText);
            Dictionary<string, List<string>> mods = new();
            string generatedPatchDirectory = Path.Combine(state.DataFolderPath, @"SKSE\Plugins\SpellResearchSynthesizer\GeneratedPatches");
            if (settings.Value.ConvertPSCToJson)
            {
                Console.WriteLine($"Creating directory {generatedPatchDirectory}...");
                Console.WriteLine(Directory.CreateDirectory(generatedPatchDirectory));
            }
            foreach ((string mod, string file) in GetJsonHardlinkedMods())
            {
                if (!mods.ContainsKey(mod.ToLower()))
                {
                    mods[mod.ToLower()] = new List<string>();
                }
                mods[mod.ToLower()].Add(file);
            }
            foreach ((string mod, string file) in GetJsonDiscoveredMods(state))
            {
                if (!mods.ContainsKey(mod.ToLower()))
                {
                    mods[mod.ToLower()] = new List<string>() { file };
                }
                else
                {
                    Console.WriteLine($"Duplicate detected: {file} for {mod}");
                }
            }
            foreach ((string mod, string file) in GetPscMods())
            {
                if (!mods.ContainsKey(mod.ToLower()))
                {
                    mods[mod.ToLower()] = new List<string>() { file };
                }
                else
                {
                    Console.WriteLine($"Duplicate detected: {file} for {mod}");
                }
            }
            List<(string mod, SpellConfiguration spells)> output = new();
            List<(string mod, ValidationResults res)> validationResults = new();
            foreach (Noggog.IKeyValue<ModKey, IModListing<ISkyrimModGetter>>? mod in state.LoadOrder)
            {
                if (mod == null) continue;
                List<string>? scriptFiles = mods.GetValueOrDefault(mod.Key.FileName.String.ToLower());
                if (scriptFiles == null) continue;
                foreach (string scriptFile in scriptFiles)
                {
                    if (string.IsNullOrEmpty(scriptFile))
                    {
                        continue;
                    }
                    Console.WriteLine($"Importing {mod.Key.FileName} from {scriptFile}");
                    (Noggog.FileName FileName, SpellConfiguration Spells)? patch = null;
                    if (scriptFile.EndsWith(".json"))
                    {
                        string jsonPath = Path.Combine(state.DataFolderPath, scriptFile);
                        if (!File.Exists(jsonPath))
                        {
                            Console.WriteLine($"JSON file {jsonPath} not found");
                            continue;
                        }
                        string spellconf = File.ReadAllText(jsonPath);
                        patch = (mod.Key.FileName, SpellConfiguration.FromJson(state, spellconf));
                    }
                    else if (scriptFile.EndsWith(".psc"))
                    {
                        string pscPath = Path.Combine(state.DataFolderPath, scriptFile);
                        if (!File.Exists(pscPath))
                        {
                            Console.WriteLine($"PSC file {pscPath} not found");
                            continue;
                        }
                        string spellconf = File.ReadAllText(pscPath);
                        patch = (mod.Key.FileName, SpellConfiguration.FromPsc(state, spellconf));
                        if (settings.Value.ConvertPSCToJson)
                        {
                            File.WriteAllText(Path.Combine(generatedPatchDirectory, $"{mod.Key.FileName.NameWithoutExtension}.json"), JsonConvert.SerializeObject(new OutputTemplate
                            {
                                NewSpells = patch.Value.Spells.Mods.SelectMany(mod => mod.Value.NewSpells).ToList(),
                                RemovedSpells = patch.Value.Spells.Mods.SelectMany(mod => mod.Value.RemovedSpells).ToList(),
                                NewArtifacts = patch.Value.Spells.Mods.SelectMany(mod => mod.Value.NewArtifacts).ToList(),
                                RemovedArtifacts = patch.Value.Spells.Mods.SelectMany(mod => mod.Value.RemovedArtifacts).ToList(),
                                NewEffects = patch.Value.Spells.Mods.SelectMany(mod => mod.Value.NewAlchemyEffects).ToList(),
                            }, Formatting.Indented));
                        }
                    }
                    if (patch != null)
                    {
                        if (!patch.Value.Spells.Validate(out ValidationResults res))
                        {
                            validationResults.Add((mod.Key.FileName, res));
                        }
                        output.Add(patch.Value);
                    }
                    else
                    {
                        Console.WriteLine("Error creating patch!");
                    }
                }
            }
            SpellConfiguration cleanedOutput = CleanOutput(output);
            OutputTemplate jsonOutput = new()
            {
                ResearchDataLists = ResearchDataLists.Instance,
                NewSpells = cleanedOutput.Mods.SelectMany(mod => mod.Value.NewSpells).ToList(),
                RemovedSpells = cleanedOutput.Mods.SelectMany(mod => mod.Value.RemovedSpells).ToList(),
                NewArtifacts = cleanedOutput.Mods.SelectMany(mod => mod.Value.NewArtifacts).ToList(),
                RemovedArtifacts = cleanedOutput.Mods.SelectMany(mod => mod.Value.RemovedArtifacts).ToList(),
                NewEffects = cleanedOutput.Mods.SelectMany(mod => mod.Value.NewAlchemyEffects).ToList(),
            };
            string path = state.DataFolderPath + @"\SKSE\Plugins\SpellResearchSynthesizer";
            Directory.CreateDirectory(path);
            File.WriteAllText(path + @"\SynthesizedPatch.json", JsonConvert.SerializeObject(jsonOutput, Formatting.Indented));
            ProcessSpells(state, cleanedOutput, archConfig);
            if (settings.Value.RemoveStartingSpells)
            {
                Console.WriteLine("Removing starting spells...");
                try
                {
                    INpcGetter player = GetPlayerBase(state);
                    Npc playerOverride = state.PatchMod.Npcs.GetOrAddAsOverride(player);
                    IEnumerable<ISpellGetter> spells = state.LoadOrder.PriorityOrder.WinningOverrides<ISpellGetter>().Where(spell => new string[] { "012FCC:Skyrim.esm", "012FCD:Skyrim.esm" }.Contains(spell.FormKey.ToString()));
                    playerOverride.ActorEffect?.Remove(spells);
                    Console.WriteLine("Spells removed");
                }
                catch (Exception ex)
                {
                    Console.WriteLine(ex.Message, ex.StackTrace);
                }
            }
            foreach ((string mod, ValidationResults res) in validationResults)
            {
                Console.WriteLine("Duplicates found:");
                PrintValidationResults(res);
            }
            if (settings.Value.GenerateFLMIni)
            {
                Console.WriteLine("Generating FLM .ini...");
                FormListContainer flmLists = new();
                foreach (ModSpellData msd in cleanedOutput.Mods.Values)
                {
                    foreach (SpellInfo spell in msd.NewSpells)
                    {
                        if (spell.SpellForm == null) throw new Exception("Form ID error");
                        if (spell.Tier == null) throw new Exception("Spell has no tier!");
                        if (spell.School == null) throw new Exception("Spell has no school!");
                        if (spell.CastingType == null) throw new Exception("Spell has no casting type!");
                        string spellFID = $"0x{spell.SpellForm.FormKey.ID:X6}~{spell.SpellESP}";
                        string flAllSpellsTier = FormatFormID(ResearchDataLists.Instance.SpellTiers[spell.Tier.Name.ToLower()]?["allSpells"]?.ToString());
                        flmLists.Add(flAllSpellsTier, spellFID);
                        string flSchool = FormatFormID(ResearchDataLists.Instance.SpellSchools[spell.School.Name.ToLower()]?.ToString());
                        flmLists.Add(flSchool, spellFID);
                        string flCastingType = FormatFormID(ResearchDataLists.Instance.SpellCastingTypes[spell.CastingType.Name.ToLower()]?.ToString());
                        flmLists.Add(flCastingType, spellFID);
                        foreach (Archetype targeting in spell.Targeting)
                        {
                            string flTargeting = FormatFormID(ResearchDataLists.Instance.SpellTargetingTypes[targeting.Name.ToLower()]?.ToString());
                            flmLists.Add(flTargeting, spellFID);
                        }
                        foreach (Archetype element in spell.Elements)
                        {
                            string flElement = FormatFormID(ResearchDataLists.Instance.SpellElements[element.Name.ToLower()]?.ToString());
                            flmLists.Add(flElement, spellFID);
                        }
                        foreach (Archetype technique in spell.Techniques)
                        {
                            string flTechnique = FormatFormID(ResearchDataLists.Instance.SpellTechniques[technique.Name.ToLower()]?.ToString());
                            flmLists.Add(flTechnique, spellFID);
                        }
                        if (spell.ScrollForm != null)
                        {
                            string scrollFID = $"0x{spell.ScrollForm.FormKey.ID:X6}~{spell.ScrollESP}";
                            string flScrolls = FormatFormID(ResearchDataLists.Instance.SpellTiers[spell.Tier.Name.ToLower()]?["scrolls"]?.ToString());
                            flmLists.Add(flScrolls, scrollFID);
                            string flScrollSpells = FormatFormID(ResearchDataLists.Instance.SpellTiers[spell.Tier.Name.ToLower()]?["scrollSpells"]?.ToString());
                            flmLists.Add(flScrollSpells, spellFID);
                        }
                        if (spell.TomeForm != null)
                        {
                            string tomeFID = $"0x{spell.TomeForm.FormKey.ID:X6}~{spell.TomeESP}";
                            string flTomes = FormatFormID(ResearchDataLists.Instance.SpellTiers[spell.Tier.Name.ToLower()]?["tomes"]?.ToString());
                            flmLists.Add(flTomes, tomeFID);
                            string flTomeSpells = FormatFormID(ResearchDataLists.Instance.SpellTiers[spell.Tier.Name.ToLower()]?["tomeSpells"]?.ToString());
                            flmLists.Add(flTomeSpells, spellFID);
                        }
                        if (!spell.Enabled)
                        {
                            string flUndiscoverable = FormatFormID(ResearchDataLists.Instance.Other["undiscoverable"]?.ToString());
                            flmLists.Add(flUndiscoverable, spellFID);
                        }
                    }
                    foreach (ArtifactInfo artifact in msd.NewArtifacts)
                    {
                        string artifactFID = FormatFormID(artifact.ArtifactID);
                        string flTier = FormatFormID(ResearchDataLists.Instance.ArtifactTiers[artifact.Tier.ToString()]?.ToString());
                        flmLists.Add(flTier, artifactFID);
                        foreach (Archetype school in artifact.Schools)
                        {
                            string flSchool = FormatFormID(ResearchDataLists.Instance.ArtifactSchools?[school.Name.ToLower()]?.ToString());
                            flmLists.Add(flSchool, artifactFID);
                        }
                        foreach (Archetype casting in artifact.CastingTypes)
                        {
                            string flCastingType = FormatFormID(ResearchDataLists.Instance.ArtifactCastingTypes[casting.Name.ToLower()]?.ToString());
                            flmLists.Add(flCastingType, artifactFID);
                        }
                        foreach (Archetype targeting in artifact.Targeting)
                        {
                            string flTargeting = FormatFormID(ResearchDataLists.Instance.ArtifactTargetingTypes[targeting.Name.ToLower()]?.ToString());
                            flmLists.Add(flTargeting, artifactFID);
                        }
                        foreach (Archetype element in artifact.Elements)
                        {
                            string flElement = FormatFormID(ResearchDataLists.Instance.ArtifactElements?[element.Name.ToLower()]?.ToString());
                            flmLists.Add(flElement, artifactFID);
                        }
                        foreach (Archetype technique in artifact.Techniques)
                        {
                            string flTechnique = FormatFormID(ResearchDataLists.Instance.ArtifactTechniques[technique.Name.ToLower()]?.ToString());
                            flmLists.Add(flTechnique, artifactFID);
                        }
                        if (artifact.Equippable)
                        {
                            string flEquippableAll = FormatFormID(ResearchDataLists.Instance.ArtifactOther["equippableAll"]?.ToString());
                            flmLists.Add(flEquippableAll, artifactFID);
                        }
                        if (artifact.EquippableArtifact)
                        {
                            string flEquppableArtifact = FormatFormID(ResearchDataLists.Instance.ArtifactOther["equippableArtifacts"]?.ToString());
                            flmLists.Add(flEquppableArtifact, artifactFID);
                        }
                        if (artifact.EquippableText)
                        {
                            string flEquippableText = FormatFormID(ResearchDataLists.Instance.ArtifactOther["equippableTexts"]?.ToString());
                            flmLists.Add(flEquippableText, artifactFID);
                        }
                    }
                    foreach (AlchemyEffectInfo effect in msd.NewAlchemyEffects)
                    {
                        string alchEffectFID = FormatFormID(effect.EffectID);
                        foreach (Archetype element in effect.Elements)
                        {
                            string flElement = FormatFormID(ResearchDataLists.Instance.AlchemyElements[element.Name.ToLower()]?.ToString());
                            flmLists.Add(flElement, alchEffectFID);
                        }
                        foreach (Archetype technique in effect.Techniques)
                        {
                            string flTechnique = FormatFormID(ResearchDataLists.Instance.AlchemyTechniques[technique.Name.ToLower()]?.ToString());
                            flmLists.Add(flTechnique, alchEffectFID);
                        }
                    }
                }
                List<string> flmOutput = new();
                foreach (KeyValuePair<string, List<string>> fl in flmLists)
                {
                    flmOutput.Add($"ModEvent = SpellResearchSynthesizerFLMImport|{fl.Key}|{string.Join(',', fl.Value)}");
                }
                File.WriteAllLines(state.DataFolderPath + @"\SpellResearchSynthesizer_FLM.ini", flmOutput);
                Console.WriteLine("FLM .ini generated succesfully");
            }
        }
        private static INpcGetter? PlayerCachedBase = null;
        private static INpcGetter GetPlayerBase(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            PlayerCachedBase ??= state.LoadOrder.PriorityOrder.WinningOverrides<INpcGetter>().First(npc => npc.FormKey.ToString() == "000007:Skyrim.esm");
            return PlayerCachedBase;
        }

        private static void PrintValidationResults(ValidationResults validationResults)
        {
            foreach (KeyValuePair<string, IEnumerable<string>> spellDuplicate in validationResults.DuplicateSpells)
            {
                Console.WriteLine($"Duplicate spell ID: {spellDuplicate.Key} - {string.Join(", ", spellDuplicate.Value)}");
            }
            foreach (KeyValuePair<string, IEnumerable<string>> spellDuplicate in validationResults.DuplicateTomes)
            {
                Console.WriteLine($"Duplicate tome ID: {spellDuplicate.Key} - {string.Join(", ", spellDuplicate.Value)}");
            }
            foreach (KeyValuePair<string, IEnumerable<string>> spellDuplicate in validationResults.DuplicateScrolls)
            {
                Console.WriteLine($"Duplicate scroll ID: {spellDuplicate.Key} - {string.Join(", ", spellDuplicate.Value)}");
            }
        }

        protected static string FormatFormID(string? fid)
        {
            if (fid == null) throw new ArgumentException("Form ID is null");
            return $"{fid.Split("|")[2]}~{fid.Split("|")[1]}";
        }
        private static ArchetypeVisualInfo LoadArchetypeVisualInfo(string configText)
        {
            ArchetypeVisualInfo archconfig = ArchetypeVisualInfo.From(configText);
            return archconfig;
        }

        private static List<(string mod, string json)> GetJsonHardlinkedMods()
        {
            return settings.Value.jsonNames.Select(x => (x.Split(";")[0].Trim(), x.Split(";")[1].Trim())).ToList();
        }

        private static List<(string mod, string json)> GetJsonDiscoveredMods(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            List<(string mod, string json)> mods = new();
            foreach (string dir in settings.Value.jsonPaths)
            {
                try
                {
                    DirectoryInfo searchDir = new(Path.Combine(state.DataFolderPath, dir));
                    foreach (FileInfo file in searchDir.GetFiles())
                    {
                        if (file.Extension == ".json")
                        {
                            string pluginName = file.Name[..file.Name.LastIndexOf(file.Extension)];
                            ModKey? mod = state.LoadOrder.FirstOrDefault(plugin => plugin.Key.Name.ToLower() == pluginName.ToLower())?.Key;
                            if (mod == null)
                            {
                                Console.WriteLine($"Found JSON file {file.Name}, but no matching plugin");
                                continue;
                            }
                            Console.WriteLine($"Found JSON file {file.Name}");
                            mods.Add(new(mod.Value.FileName, Path.Combine(dir, file.Name)));
                        }
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine(ex.Message);
                }
            }
            return mods;
        }

        private static List<(string mod, string psc)> GetPscMods()
        {
            return settings.Value.pscnames.Select(x => (x.Split(";")[0].Trim(), x.Split(";")[1].Trim())).ToList();
        }
        private static SpellConfiguration CleanOutput(List<(string mod, SpellConfiguration spells)> output)
        {
            SpellConfiguration result = new();
            foreach ((_, SpellConfiguration spellConfiguration) in output)
            {
                foreach ((string mod, ModSpellData forms) in spellConfiguration.Mods)
                {
                    foreach (SpellInfo spell in forms.RemovedSpells)
                    {
                        Console.WriteLine($"Removing spell {spell.Name} from {spell.SpellESP}");
                        result.Mods[spell.SpellESP].NewSpells.Remove(result.Mods[spell.SpellESP].NewSpells.FirstOrDefault(s => s.SpellFormID == spell.SpellFormID) ?? new SpellInfo());
                        result.Mods[spell.SpellESP].RemovedSpells.Add(spell);
                    }
                    foreach (SpellInfo spell in forms.NewSpells)
                    {
                        if (!result.Mods.ContainsKey(spell.SpellESP))
                        {
                            Console.WriteLine($"Adding mod {spell.SpellESP}");
                            result.Mods.Add(spell.SpellESP, new ModSpellData());
                        }
                        SpellInfo? oldEntry = result.Mods[spell.SpellESP].NewSpells.FirstOrDefault(x => x.SpellFormID == spell.SpellFormID);
                        if (oldEntry != null)
                        {
                            Console.WriteLine($"Removing spell {oldEntry.Name} from {spell.SpellESP} (overwritten by {spell.Name} from {mod})");
                            result.Mods[spell.SpellESP].NewSpells.Remove(oldEntry);
                            result.Mods[spell.SpellESP].RemovedSpells.Add(oldEntry);
                        }
                        if (settings.Value.IgnoreDiscoverable && (!spell.HardRemoved) && (spell.TomeForm != null) && (!spell.Enabled))
                        {
                            Console.WriteLine($"Overriding discoverability of spell {spell.Name}");
                            spell.Enabled = true;
                            result.Mods[spell.SpellESP].RemovedSpells.Add(new SpellInfo
                            {
                                Name = spell.Name,
                                Tier = spell.Tier,
                                School = spell.School,
                                CastingType = spell.CastingType,
                                Targeting = spell.Targeting,
                                Elements = spell.Elements,
                                Techniques = spell.Techniques,
                                SpellForm = spell.SpellForm,
                                TomeForm = spell.TomeForm,
                                ScrollForm = spell.ScrollForm,
                                Enabled = false
                            });
                        }
                        Console.WriteLine($"Adding spell {spell.Name} to {spell.SpellESP}");
                        result.Mods[spell.SpellESP].NewSpells.Add(spell);
                    }
                    foreach (ArtifactInfo artifact in forms.NewArtifacts)
                    {
                        if (!result.Mods.ContainsKey(artifact.ArtifactESP))
                        {
                            result.Mods.Add(artifact.ArtifactESP, new ModSpellData());
                        }
                        ArtifactInfo? oldEntry = result.Mods[artifact.ArtifactESP].NewArtifacts.FirstOrDefault(x => x.ArtifactID.ToLower() == artifact.ArtifactID.ToLower());
                        if (oldEntry != null)
                        {
                            result.Mods[artifact.ArtifactESP].NewArtifacts.Remove(oldEntry);
                            result.Mods[artifact.ArtifactESP].RemovedArtifacts.Add(oldEntry);
                        }
                        result.Mods[artifact.ArtifactESP].NewArtifacts.Add(artifact);
                    }
                    foreach (ArtifactInfo artifact in forms.RemovedArtifacts)
                    {
                        result.Mods[artifact.ArtifactESP].RemovedArtifacts.Add(artifact);
                    }
                    foreach (AlchemyEffectInfo effect in forms.NewAlchemyEffects)
                    {
                        if (!result.Mods.ContainsKey(effect.EffectESP))
                        {
                            result.Mods.Add(effect.EffectESP, new ModSpellData());
                        }
                        if (!result.Mods[effect.EffectESP].NewAlchemyEffects.Contains(effect))
                        {
                            result.Mods[effect.EffectESP].NewAlchemyEffects.Add(effect);
                        }
                    }
                }
            }
            foreach ((string mod, ModSpellData forms) in result.Mods)
            {
                List<SpellInfo> HardRemoved = forms.NewSpells.Where(s => s.HardRemoved).ToList();
                foreach (SpellInfo s in HardRemoved)
                {
                    Console.WriteLine($"Hard removing {s.Name} from {mod}");
                    forms.NewSpells.Remove(s);
                    forms.RemovedSpells.Add(s);
                }
            }

            return result;
        }

        private static void ProcessSpells(IPatcherState<ISkyrimMod, ISkyrimModGetter> state, SpellConfiguration spellInfo, ArchetypeVisualInfo archConfig)
        {
            if (spellInfo == null)
            {
                Console.WriteLine("Failed to read file");
                return;
            }
            if (!spellInfo.Mods.SelectMany(mod => mod.Value.NewSpells).Any())
            {
                Console.WriteLine("No spells found");
                return;
            }
            foreach ((string modName, ModSpellData msd) in spellInfo.Mods)
            {
                foreach (SpellInfo spell in msd.NewSpells)
                {
                    if (spell.Tier == null) throw new Exception("Spell has no tier!");
                    if (spell.School == null) throw new Exception("Spell has no school!");
                    if ((!spell.Enabled) || spell.TomeForm == null) continue;
                    IBookGetter? bookRecord = state.LinkCache.TryResolve<IBookGetter>(spell.TomeForm.FormKey, out IBookGetter? _out) ? _out : null;
                    if (bookRecord == null)
                    {
                        Console.WriteLine("ERROR: Could Not Resolve {0}", spell.TomeForm);
                        continue;
                    }
                    else
                    {
                        Console.WriteLine(bookRecord);
                        LevelSettings s;
                        switch (spell.Tier.Name.ToLower())
                        {
                            case "novice":
                                {
                                    s = settings.Value.Novice;
                                    break;
                                }
                            case "apprentice":
                                {
                                    s = settings.Value.Apprentice;
                                    break;
                                }
                            case "adept":
                                {
                                    s = settings.Value.Adept;
                                    break;
                                }
                            case "expert":
                                {
                                    s = settings.Value.Expert;
                                    break;
                                }
                            case "master":
                                {
                                    s = settings.Value.Master;
                                    break;
                                }
                            default:
                                {
                                    s = new();
                                    break;
                                }
                        }
                        if (!s.Process)
                        {
                            continue;
                        }
                        string desc = ProcessText(spell, archConfig, s).Trim();

                        string? font = s.Font;
                        Regex rnamefix = new("^.+\\s+(Tome)\\:?(?<tomename>.+)$", RegexOptions.Compiled | RegexOptions.IgnoreCase);
                        //var font = config["Fonts"]?[archetypemap["level"]].ToString() ?? "$HandwrittenFont";
                        string? name = bookRecord.Name?.String ?? $"Spell Tome: {spell.Name}";

                        if (font.Equals("$FalmerFont") || font.Equals("$DragonFont") || font.Equals("$MageScriptFont"))
                        {

                            char[] tagsep = new char[] { '<', '>', '#', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' };
                            char[] separators = new char[] { '!', '@', '$', '%', '^', '&', '*', '(', ')', '{', '}', '[', ']', '-', '_', '+', ':', '"', ';', ',', '.', '?', '~' };

                            desc = desc.ToUpper();
                            name = name.ToUpper();

                            string[] tempdesc = desc.Split(separators, StringSplitOptions.RemoveEmptyEntries);
                            string[] tempname = name.Split(separators, StringSplitOptions.RemoveEmptyEntries);

                            desc = string.Join("", tempdesc);
                            name = string.Join("", tempname);
                        }

                        string PREAMBLE = $"<br><br><p align=\"center\"><font face='{font}'><font size='40'></font>";
                        string imgpath = "";
                        string img = "";

                        if (s.UseImage)
                        {
                            if (spell.Elements.Count > 0)
                            {
                                imgpath = archConfig.Archetypes[spell.Elements[0].Name.ToLower()].Image ?? "";
                            }
                            else if (spell.Techniques.Count > 0)
                            {
                                imgpath = archConfig.Archetypes[spell.Techniques[0].Name.ToLower()].Image ?? "";
                            }

                            if (!imgpath.Equals(""))
                            {
                                img = $"<br><br><img src='img://{imgpath}' height='296' width='296'>";
                            }
                        }
                        string PAGE = $"<br><br></p>[pagebreak]<br><br><p align=\"left\"><font face='{font}'><font size='40'></font>";
                        string POST = "</font></p>";

                        string? btext = PREAMBLE + name + img + PAGE + desc + POST;
                        btext = Regex.Replace(btext, @"FONT\s*(COLOR)*", m => m.Value.ToLower());
                        Console.WriteLine("DESC: {0}", btext);
                        Book? bookOverride = state.PatchMod.Books.GetOrAddAsOverride(bookRecord);
                        if (settings.Value.ExperimentalTeachesSpellFix)
                        {
                            bookOverride.Teaches?.Clear();
                        }
                        else
                        {
                            bookOverride.Teaches = new BookTeachesNothing();
                        }
                        bookOverride.BookText = btext;
                        bookOverride.VirtualMachineAdapter ??= new();
                        if (s.NoviceExperience > 0 || s.ApprenticeExperience > 0 || s.AdeptExperience > 0 || s.ExpertExperience > 0 || s.MasterExperience > 0)
                        {
                            ScriptEntry script = new()
                            {
                                Name = "SpellResearchSynthesizerBookReadScript",
                                Properties = new Noggog.ExtendedList<ScriptProperty> {
                                    new ScriptObjectProperty {
                                        Name = "Tome",
                                        Object = bookOverride.ToLink<IBookGetter>()
                                    },
                                    new ScriptObjectProperty {
                                        Name = "ReadTomeList",
                                        Object = GetTomeList(state, spell.School, spell.Tier)
                                    },
                                    new ScriptStringProperty {
                                        Name = "Skill",
                                        Data = spell.School.Name,
                                    },
                                    new ScriptIntProperty
                                    {
                                        Name = "SkillRequired",
                                        Data = s.SkillRequired,
                                    },
                                    new ScriptIntProperty {
                                        Name = "FirstPerson",
                                        Data = settings.Value.FirstPerson ? 1 : 0,
                                    }
                                }
                            };
                            FillScriptGlobals(state, script.Properties, spell, s.NoviceExperience, s.ApprenticeExperience, s.AdeptExperience, s.ExpertExperience, s.MasterExperience);
                            bookOverride.VirtualMachineAdapter.Scripts.Add(script);
                        }
                    }
                }
            }
        }

        private static void FillScriptGlobals(IPatcherState<ISkyrimMod, ISkyrimModGetter> state, Noggog.ExtendedList<ScriptProperty> properties, SpellInfo spell, int noviceExperience, int apprenticeExperience, int adeptExperience, int expertExperience, int masterExperience)
        {
            ArchetypeInfo archetypes = ArchetypeInfo.Instance;
            ScriptObjectListProperty globals = new()
            {
                Name = "Archetypes"
            };
            ScriptIntListProperty values = new()
            {
                Name = "XPValues"
            };
            if (noviceExperience > 0)
            {
                FillScriptGlobals(state, spell, globals, values, noviceExperience, archetypes.GetArchetype(ArchetypeType.Tier, "Novice") ?? throw new Exception());
            }
            if (apprenticeExperience > 0)
            {
                FillScriptGlobals(state, spell, globals, values, apprenticeExperience, archetypes.GetArchetype(ArchetypeType.Tier, "Apprentice") ?? throw new Exception());
            }
            if (adeptExperience > 0)
            {
                FillScriptGlobals(state, spell, globals, values, adeptExperience, archetypes.GetArchetype(ArchetypeType.Tier, "Adept") ?? throw new Exception());
            }
            if (expertExperience > 0)
            {
                FillScriptGlobals(state, spell, globals, values, expertExperience, archetypes.GetArchetype(ArchetypeType.Tier, "Expert") ?? throw new Exception());
            }
            if (masterExperience > 0)
            {
                FillScriptGlobals(state, spell, globals, values, masterExperience, archetypes.GetArchetype(ArchetypeType.Tier, "Master") ?? throw new Exception());
            }
            properties.Add(globals);
            properties.Add(values);
        }
        static readonly Dictionary<string, IGlobalGetter> GlobalCache = new();

        private static void FillScriptGlobals(IPatcherState<ISkyrimMod, ISkyrimModGetter> state, SpellInfo spell, ScriptObjectListProperty globals, ScriptIntListProperty values, int xp, Archetype tier)
        {
            string edidSkill = spell.School?.Tiers?[tier].GlobalEditorID ?? throw new Exception("Spell has no school!");
            if (!GlobalCache.ContainsKey(edidSkill))
            {
                GlobalCache[edidSkill] = state.LinkCache.TryResolve<IGlobalGetter>(edidSkill, out IGlobalGetter? _skill) ? _skill : throw new Exception($"Failed to find skill global variable {edidSkill}!"); ;
            }
            IGlobalGetter skill = GlobalCache[edidSkill];
            globals.Objects.Add(new ScriptObjectProperty
            {
                Object = skill.ToLink<IGlobal>()
            });
            values.Data.Add(xp);
            string edidCastingType = spell.CastingType?.Tiers?[tier].GlobalEditorID ?? throw new Exception("Spell has no casting type!");
            if (!GlobalCache.ContainsKey(edidCastingType))
            {
                GlobalCache[edidCastingType] = state.LinkCache.TryResolve<IGlobalGetter>(edidCastingType, out IGlobalGetter? _castingType) ? _castingType : throw new Exception($"Failed to find skill global {edidCastingType}");
            }
            IGlobalGetter castingType = GlobalCache[edidCastingType];
            globals.Objects.Add(new ScriptObjectProperty
            {
                Object = castingType.ToLink<IGlobal>()
            });
            values.Data.Add(xp);
            foreach (Archetype arch in spell.Targeting.Union(spell.Elements).Union(spell.Techniques))
            {
                string edidArch = arch.Tiers?[tier].GlobalEditorID ?? throw new Exception($"Error resolving global ID for {arch.Name} {tier.Name}");
                if (!GlobalCache.ContainsKey(edidArch))
                {
                    GlobalCache[edidArch] = state.LinkCache.TryResolve<IGlobalGetter>(edidArch, out IGlobalGetter? _global) ? _global : throw new Exception($"Failed to find skill global {edidArch}");
                }
                IGlobalGetter global = GlobalCache[edidArch];
                globals.Objects.Add(new ScriptObjectProperty
                {
                    Object = global.ToLink<IGlobal>()
                });
                values.Data.Add(xp);
            }
        }

        private static readonly Dictionary<string, IFormLink<IFormListGetter>> TomeFormLists = new();

        private static IFormLink<ISkyrimMajorRecordGetter> GetTomeList(IPatcherState<ISkyrimMod, ISkyrimModGetter> state, Archetype school, Archetype tier)
        {
            string editorID = $"SRS_Tome_{school.Name}_{tier.Name}";
            if (!TomeFormLists.ContainsKey(editorID))
            {
                TomeFormLists[editorID] = state.LinkCache.TryResolve<IFormListGetter>(editorID, out IFormListGetter? list) ? list.FormKey.ToLink<IFormListGetter>() : throw new Exception($"Failed to resolve {editorID}");
            }
            return TomeFormLists[editorID];
        }
    }

}
